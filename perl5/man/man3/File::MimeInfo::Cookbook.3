.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "File::MimeInfo::Cookbook 3"
.TH File::MimeInfo::Cookbook 3 2024-01-22 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
File::MimeInfo::Cookbook \- various code snippets
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Some code snippets for non-basic uses of the File::MimeInfo
module:
.IP "\fBMatching an extension\fR" 4
.IX Item "Matching an extension"
A file does not have to actually exist in order to get a
mimetype for it. This means that the following will work:
.Sp
.Vb 2
\&  my $extension = \*(Aq*.txt\*(Aq;
\&  my $mimetype = mimetype( $extension );
.Ve
.IP "\fBMimetyping an scalar\fR" 4
.IX Item "Mimetyping an scalar"
If you want to find the mimetype of a scalar value you need magic
mimetyping; after all a scalar doesn't have a filename or inode.
What you need to do is to use IO::Scalar :
.Sp
.Vb 2
\&  use File::MimeInfo::Magic;
\&  use IO::Scalar;
\&
\&  my $io_scalar = new IO::Scalar \e$data;
\&  my $mimetype = mimetype( $io_scalar );
.Ve
.Sp
In fact most other \f(CW\*(C`IO::\*(C'\fR will work as long as they support the \f(CWseek()\fR
and \f(CWread()\fR methods. Of course if you want really obscure things to
happen you can always write your own IO object and feed it in there.
.Sp
Be aware that when using a filehandle like this you need to set the \f(CW\*(C`:utf8\*(C'\fR
binmode yourself if appropriate.
.IP "\fBMimetyping a filehandle\fR" 4
.IX Item "Mimetyping a filehandle"
Regrettably for non-seekable filehandles like STDIN simply using an \f(CW\*(C`IO::\*(C'\fR
object will not work. You will need to buffer enough of the data for a proper
mimetyping. For example you could mimetype data from STDIN like this:
.Sp
.Vb 2
\&  use File::MimeInfo::Magic;
\&  use IO::Scalar;
\&
\&  my $data;
\&  read(STDIN, $data, $File::MimeInfo::Magic::max_buffer);
\&  my $io_scalar = new IO::Scalar \e$data;
\&  my $mimetype = mimetype( $io_scalar );
.Ve
.Sp
Be aware that when using a filehandle like this you need to set the \f(CW\*(C`:utf8\*(C'\fR
binmode yourself if appropriate.
.IP "\fBCreating a new filename\fR" 4
.IX Item "Creating a new filename"
Say you have a temporary file that you want to save with a more
proper filename.
.Sp
.Vb 2
\&  use File::MimeInfo::Magic qw#mimetype extensions#;
\&  use File::Copy;
\&
\&  my $tmpfile = \*(Aq/tmp/foo\*(Aq;
\&  my $mimetype = mimetype($tmpfile);
\&  my $extension = extensions($mimetype);
\&  my $newfile = \*(Aquntitled1\*(Aq;
\&  $newfile .= \*(Aq.\*(Aq.$extension if length $extension;
\&  move($tmpfile, $newfile);
.Ve
.IP "\fBForce the use of a certain database directory\fR" 4
.IX Item "Force the use of a certain database directory"
Normally you just need to add the dir where your mime database lives
to either the XDG_DATA_HOME or XDG_DATA_DIRS environment variables
for it to be found. But in some rare cases you may want to by-pass
this system all together. Try one of the following:
.Sp
.Vb 3
\&  @File::MimeInfo::DIRS = (\*(Aq/home/me/share/mime\*(Aq);
\&  eval \*(Aquse File::MimeInfo\*(Aq;
\&  die if $@;
.Ve
.Sp
or:
.Sp
.Vb 3
\&  use File::MimeInfo;
\&  @File::MimeInfo::DIRS = (\*(Aq/home/me/share/mime\*(Aq);
\&  File::MimeInfo\->rehash();
.Ve
.Sp
This can also be used for switching between databases at run time
while leaving other XDG configuration stuff alone.
.SH AUTHOR
.IX Header "AUTHOR"
Jaap Karssenberg <pardus@cpan.org>
Maintained by Michiel Beijen <mb@x14.nl>
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (c) 2005, 2012 Jaap G Karssenberg. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::MimeInfo
